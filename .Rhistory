#' @return a list containing the criterion evaluated at grid points and the result of the wald test
get_results <- function(grid,shift,getTestResults,rm,metric){
out <- lapply(metric,function(metric){
criterion_values = list(values = unlist(lapply(grid$betas_grid,metric)))
if(is.null(shift)){
# to catch and handle strange inputs resulting in all almost zero criterion values during the simulation
if(all(abs(criterion_values$values)<1e-5)){
idx = which(
unlist(lapply(X = grid$betas_grid,FUN = function(x){
if(abs(x[1,3])<1e-2){
x[,3] = rep(0,length(x[,3]))
return(1)
}else return(0)
}))
==1)
len_argmax = length(idx)
if(len_argmax>1){
if(!len_argmax%%2) shift = mean(c(grid$c_grid[[idx[len_argmax/2]]],grid$c_grid[[idx[len_argmax/2+1]]]))
else shift = grid$c_grid[[idx[ceiling(len_argmax/2)]]]
}else shift = grid$c_grid[[idx]]
}else{
idx = which.max(criterion_values$values)
shift = grid$c_grid[[idx]]
value = criterion_values$values[idx]
}
}else{
if(length(shift)==1){
idx = which.min(abs(grid$c_grid-shift))
value = criterion_values$values[idx]
}
else print("not a valid shift")
}
TestResults = NA
if(getTestResults){
if(!all(is.na(rm))){
TestResults = getWald(rm,shift = shift)$p
}else warning("Need rasch model object to perform wald test. Set argument getTestResults in criterion_plot() to FALSE to avoid warning message.")
}
criterion_values$cshift = data.frame(shift = shift,idx = idx,value = value)
return(list(criterion_values = criterion_values,TestResults = TestResults))
})
out$shifts = grid$c_grid
return(out)
}
#' criterion function
#' @param rm1 Fitted Rasch Model object corresponding to the first group. Object is of class "raschmodel", produced by function \code{raschmodel} of the package \pkg{psychotools}.
#' @param rm2  Fitted Rasch Model object corresponding to the second group. Object is of class "raschmodel", produced by function \code{raschmodel} of the package \pkg{psychotools}.
#' @param select criterion: Gini Index or CLF Criterion
#' @param grid  grid method: symmetric or sparse
#' @param shift  desired shift. if NULL, then the criterion maximizing is used. Can also be numeric to get desired shift. Caution: must be within grid!
#' @return a list "resultlist" which contains: grid values, criterion values, rm object, coefficients and information about generating mechanism
getCriterionRes <- function(rm1, rm2, select = c("Gini Index","CLF Criterion"), grid = c("symmetric","sparse"), shift = NULL){
select <- match.arg(select, several.ok = TRUE)
grid <- match.arg(grid, several.ok = TRUE)
metrics <- list('Gini Index' = function(x) return(ifelse(test = all(x[,3]==0),yes = 0,no = ineq::Gini(abs(x[,3])))),
'CLF Criterion' = function(x) -1*clfCriterion(x[,3],eps = 0)
)
rm <- list(rm1 = rm1,rm2 = rm2)
cf1 = c(0,stats::coef(rm$rm1))
cf2 = c(0,stats::coef(rm$rm2))
resultList <- list()
gridOK <- c("sparse","symmetric") %in% grid
names(gridOK) <- c("sparse","symmetric")
x_range <- list(sparse = c(min(cf1 - cf2),max(cf1 - cf2)),symmetric = c((min(cf1)-max(cf2)), max(cf1) - min(cf2)))[gridOK]
if(is.null(shift) || any(gridOK <- (shift<sapply(x_range,function(x)x[2]))&(shift>sapply(x_range,function(x)x[1])))){
Grid_list <- generateGrid(beta1 = cf1,beta2 = cf2, grid_method = names(which(gridOK[grid])))
resultList$res <- lapply(Grid_list,FUN = get_results,shift = shift, getTestResults = TRUE,rm = rm,metric = metrics[select])
}else stop("shift is outside grid")
resultList$rm <- rm
return(resultList)
}
#########
#Plot functions
#' Function to produce criterion plot
#' @param object anchorpoint object as produced by the function \code{anchorpoint}
#' @param names list, with criterion and grid: names of the methods used.
#' @param location_picker use location picker
#' @param lty line type
#' @param col color
#' @param cex.axis cex.axis
#' @param cex.lab cex.lab
#' @param cex.main cex.main
#' @param cex cex
#' @return selected points with additional information
plotCriterion <- function(object,names,location_picker = FALSE,lty = 1,col = 1,cex.axis = 1,cex.lab = 1, cex.main = 1,cex = 1){
results_list <- object
#0-1 scaling
scaler <- function(dat){
shift = min(dat)
scale = (max(dat)-shift)
return((dat-shift)/scale)
}
criterion_values <- results_list$criterion_value
criterion_values_scaled  <- scaler(criterion_values)
grid_list <- results_list$shift
margin <- c(-1,1)*0.025
x_range <- range(results_list$shift) + margin
plot(x=NULL,y=NULL, xaxt="n",yaxt="n",xlim=x_range, ylim=c(0,1) + margin, ylab = "Normalized criterion value", xlab = "Shift c",main =  paste("Criterion:",names$criterion, "-", "Grid:",names$grid,sep = " "),cex.main = cex.main, cex.lab = cex.lab)
graphics::axis(side=1, at=seq(floor(x_range[1]),ceiling(x_range[2]),0.1), cex.axis = cex.axis)
graphics::axis(side=2, at=seq(0,1,0.1), cex.axis = cex.axis)
graphics::lines(x = grid_list, y = criterion_values_scaled,type = 'l', "Normalized criterion value", xlab = "Shift c", lty = 1, col = col)
graphics::legend("topright",legend = names$criterion,lty = lty,col = col)
if(location_picker){
cat("Move the cross to the point whose position is wanted. \n")
#Selection of grid points on plot
points <- graphics::identify(x = grid_list,y = criterion_values_scaled,tolerance = 0.5,labels = paste("c  = ",round(grid_list,2),sep = ""),offset = 0,cex = cex)
lenP <- length(points)
if(lenP){
graphics::segments(x0 = grid_list[points],x1 = grid_list[points],y0 = rep(-.1,lenP),y1 = criterion_values_scaled[points],col = scales::alpha(col,.25),lty = 2)
out <- cbind(grid_list[points],criterion_values_scaled[points], criterion_values[points], points, results_list$anchor_item[points])
colnames(out) <- c("shift", "scaled criterion value", "criterion value", "grid position", "anchor item")[1:dim(out)[2]]
rownames(out) <- paste("pick", 1:lenP,sep = " ")
return(as.data.frame(out))
}
}
}
#' Function to produce graphical test plot
#' @param object anchorpoint object as produced by the function \code{anchorpoint}
#' @param shift   numeric, shift which is applied, default NULL (global optimum)
#' @param highlight  positive integer, items to be highlighted (invalid items are excluded).
#' @param alpha   significance level for DIF test
#' @param testColors  list with colors for the items:
#' - "not significant" = "darkgreen"
#' - "significant" = "red3"
#' - "anchor item" = "black"
#' @param TestResults  waldtest object from anchorpoint::getWald. If NULL, then they are computed within the function. Default: NULL.
#' @param ask logical, ask for next plot. Default = TRUE
#' @param ...   further arguments for plot() like lty, cex.axis, cex.main, cex.lab etc.
#' credit: some code is adapted from the function plotGOF of the R package eRm.
#' @export
graphicalTest <- function(object,shift = NULL,highlight = NULL,alpha = 0.05,
testColors = list("not significant"="darkgreen","significant"="red3","anchor
item"="black"),TestResults = NULL,ask = TRUE,...){
if (!inherits(object, "anchorpoint"))
stop("use only with \"anchorpoint\" objects")
# Do plot with a specific shift
plt <- function(shift,...){
stopifnot("Shift must be numeric" = is.numeric(shift))
if (!inherits(TestResults, "waldtest")) TestResults <- getWald(object$rm,shift = shift)
beta1 <- c(0, stats::coef(object$rm$rm1))
cf2 <- c(0, stats::coef(object$rm$rm2))
beta2 <- cf2 + shift
len <- length(beta1)
results <- rep(NA, len)
names(results) <- colnames(object$rm$rm1$data)
aliased_item <- which(is.na(TestResults$p))
#standard approach (extracting variance estimation from rasch model fit & calculating p-values with test statistic: diff(b1,b2)/sqrt(var1_hat + var2_hat) ~ N(0,1)
# (thats how it was implemented - as we deal with unknown variances, a t-test would probably more suitable..)
standard <- function(){
vars <- diag(TestResults$vcov)
v1 = rep(0,length(beta1))
v1[seq(1:length(beta1))[-aliased_item]] <- vars[1:length(beta1)-1]
v2 = rep(0,length(beta1))
v2[seq(1:length(beta1))[-aliased_item]] <- vars[-(1:length(beta1)-1)]
return(list(s1 = sqrt(v1), s2 = sqrt(v2), pvalues = TestResults$p))
}
res <- standard()
results[seq(1:len)[-aliased_item]] <- res$pvalues[-aliased_item]
names(testColors) <- c("not significant","significant","anchor item")
if(!is.list(testColors)) testColors = as.list(testColors)
colVec = rep(testColors$`not significant`,length(beta1))
colVec[which(results<alpha)] <- testColors$significant
colVec[which(is.na(results))] <- testColors$`anchor item`
z <- stats::qnorm(alpha/2.0, lower.tail = FALSE)
setRange <- max(diff(range(beta1)+c(-1,1)*stats::var(beta1)/2),diff(range(beta2)+c(-1,1)*stats::var(beta2)/2))
rangeBeta1 <- min(beta1) + diff(range(beta1))/2 +c(-1,1)*setRange/2
rangeBeta2 <- min(beta2) + diff(range(beta2))/2 +c(-1,1)*setRange/2
ci1u <- beta1 + z*res$s1
ci1l <- beta1 - z*res$s1
ci2u <- beta2 + z*res$s2
ci2l <- beta2 - z*res$s2
pchVector = rep(20,length(beta1))
pchVector[aliased_item] <- 18
plot(beta1,beta2,xlim = rangeBeta1,ylim = rangeBeta2,pch = pchVector,col = scales::alpha(colVec, 0.8),main = "Graphical Test Plot",xlab = "Item Parameters group 0",ylab = "Item Parameters group 1",...)
graphics::abline(coef = c(0,1))
graphics::text(x = beta1,y = beta2,labels =  1:length(beta1), cex= 0.5,pos = 4,col=colVec)
# simple ellipse to replace the function ellipse() from the car package
simple_ellipse <- function(center, a, b, n = 200L, border_col, col){
angle_t <- seq(0, 2*pi, length.out = n)[-1L]
graphics::polygon(center[1L] + a * cos(angle_t), center[2L] + b * sin(angle_t), lwd = 1.0, border = border_col,col = col)
}
highlight <- if(is.null(highlight)) numeric(0)
else if(is.character(highlight)) as.numeric(highlight)
else if(highlight == "significant") which(results<alpha)
for(i in 1:length(beta1)){
graphics::segments( x0 = c(beta1[i], ci1l[i]), y0 = c(ci2l[i], beta2[i]),
x1 = c(beta1[i], ci1u[i]), y1 = c(ci2u[i], beta2[i]),
col = scales::alpha(colVec[i], 0.4),lwd = 1,...)
simple_ellipse( center = c(beta1[i],beta2[i]),
a = abs(diff(c(ci1u[i],ci1l[i])))/2,
b = abs(diff(c(ci2u[i],ci2l[i])))/2,
n = 200L, border_col = scales::alpha(colVec[i], 0.9), col = if(i %in% highlight) scales::alpha(colVec[i], 0.4) else NA)
}
}
if(is.null(shift)){
if(ask){
oask <- grDevices::devAskNewPage(TRUE)
on.exit(grDevices::devAskNewPage(oask))
}
temp <- object$all_results
for(grid in names(temp)){
for(criterion in names(temp[[grid]])){
plt(object$global_optimum[[grid]][[criterion]]$shift,...)
}
}
}else plt(shift,...)
}
#' Function to produce shift Plot
#' @param object anchorpoint object as produced by the function \code{anchorpoint}
#' @param shift   numeric, shift which is applied
#' @param testColors  list with colors for the items:
#' - "not significant" = "darkgreen"
#' - "significant" = "red3"
#' - "anchor item" = "black"
#' @param addLegend  logic, add a legend to the plot, default: False
#' @param highlight  positive integer, items to be highlighted (invalid items are excluded).
#' @param digits  positive integer, controls rounding of the shift in title
#' @param cex.legend  numeric,  controls size of legend
#' @param TestResults  waldtest object from anchorpoint::getWald. If NULL, then they are computed within the function. Default: NULL.
#' @param ask logical, ask for next plot. Default = TRUE
#' @param ...  additional graphics arguments
#' @export
shiftPlot <- function(object, shift = NULL,
testColors = list("not significant"="darkgreen","significant"="red3","anchor
item"="black"), # colors for no significant DIF, significant DIF and anchor item
addLegend = TRUE,highlight = NULL,digits = 3,cex.legend  = 1,TestResults = NULL,ask = TRUE,...){
if (!inherits(object, "anchorpoint"))
stop("use only with \"anchorpoint\" objects")
# Do plot with a specific shift
plt <- function(shift,...){
stopifnot("Shift must be numeric" = is.numeric(shift))
if(is.null(names(testColors))) names(testColors) <- list("not significant","significant","anchor item")
cf1 = c(0,stats::coef(object$rm$rm1))
cf2 = c(0,stats::coef(object$rm$rm2))
if(length(highlight)>0){
highlight = as.integer(highlight)
range_violation = which((highlight<1)|(highlight>length(cf1))|is.na(highlight))
if(length(range_violation)>0){
warning("Some invalid items to be highlighted got excluded!")
highlight = highlight[-range_violation]
}
}
if (!inherits(TestResults, "waldtest")) TestResults <- getWald(object$rm,shift = shift)
col = rep(testColors[[1]],length(cf2))
col[which(TestResults$p<=0.05)] = testColors[[2]]
col[which(is.na(TestResults$p))] = testColors[[3]]
cf2_shifted = cf2 + shift
ylimits = range(c(range(cf2_shifted),range(cf1)))
#ylimits[1] <- ylimits[1] - diff(ylimits)*0.1
if(length(highlight)>0){
x0 = highlight-0.4
x1 = highlight+0.4
y0 = ylimits[1]-.5
y1 = ylimits[2]+.5
plot(cf1,
xlab = "Item", ylab = "Parameter",
ylim = ylimits,
xaxt="n",col = 1,
panel.first = c(graphics::abline(v = highlight, lty = 2, col = 'grey'),
graphics::rect(x0,y0,x1,y1, col= grDevices::rgb(1,1,0,alpha=0.25),border = NA)),
main = paste("Shifted item parameters at global optimum c = ",round(shift,digits = digits),sep = " "),...)
graphics::text(highlight+0.25, ylimits[1]-0.1,labels = highlight,cex = 0.6)
}else{
plot(cf1, xlab = "Item", ylab = "Parameter",
ylim = ylimits,
xaxt="n",col = 1,
main = paste("Shifted item parameters at global optimum c = ",round(shift,digits = digits),sep = " "))
}
graphics::points(cf2_shifted,col=col,pch = 4,cex = 1)
graphics::axis(side=1, at=seq(1,length(cf1)))
if(addLegend) graphics::legend("top",legend = names(testColors),col = unlist(testColors),pch = 4,bty = 'n',ncol=3,  inset =  -.1,xpd = T,cex = cex.legend)
}
if(is.null(shift)){
if(ask){
oask <- grDevices::devAskNewPage(TRUE)
on.exit(grDevices::devAskNewPage(oask))
}
temp <- object$all_results
for(grid in names(temp)){
for(criterion in names(temp[[grid]])){
plt(object$global_optimum[[grid]][[criterion]]$shift,...)
}
}
}else plt(shift,...)
}
waldtestpV(anchorpoint_test)
waldtestpV(anchorpoint_test, shift = -1)
shift = -1
!is.null(shift) && is.numeric(shift)
object$rm
#' Print function for waldtestpV object
#' @param x  waldtest object
#' @param ... further arguments passed to or from other methods.
#' @export
print.waldtestpV <- function(x,...) {
if (!inherits(x, "waldtestpV"))
stop("use only with \"waldtestpV\" objects")
if("shift" %in% names(x)){
cat(paste("Wald test p-values for shift = ",out$shift,":",sep = ""),"\n")
print(x$pv,...)
cat("\n")
}else{
for(grid in names(x)){
for(criterion in names(x[[grid]])){
cat(paste("Wald test p-values for",grid,"grid with",criterion,"measure:",sep = " "),"\n")
print(x[[grid]][[criterion]],...)
cat("\n")
}
}
}
}
waldtestpV(anchorpoint_test, shift = -1)
#' Print function for waldtestpV object
#' @param x  waldtest object
#' @param ... further arguments passed to or from other methods.
#' @export
print.waldtestpV <- function(x,...) {
if (!inherits(x, "waldtestpV"))
stop("use only with \"waldtestpV\" objects")
if("shift" %in% names(x)){
cat(paste("Wald test p-values for shift = ",x$shift,":",sep = ""),"\n")
print(x$pv,...)
cat("\n")
}else{
for(grid in names(x)){
for(criterion in names(x[[grid]])){
cat(paste("Wald test p-values for",grid,"grid with",criterion,"measure:",sep = " "),"\n")
print(x[[grid]][[criterion]],...)
cat("\n")
}
}
}
}
waldtestpV(anchorpoint_test, shift = -1)
waldtestpV(anchorpoint_test, shift = -3)
waldtestpV(anchorpoint_test, shift = 1)
# rounds the values in its first argument to the specified number of significant digits.
waldtest(anchorpoint_test, c = -1,digits = 2)
# rounds the values in its first argument to the specified number of significant digits.
waldtestpV(anchorpoint_test, c = -1,digits = 2)
# rounds the values in its first argument to the specified number of significant digits.
waldtestpV(anchorpoint_test, shift = -1,digits = 2)
# rounds the values in its first argument to the specified number of significant digits.
waldtestpV(anchorpoint_test, shift = -1,digits = 5)
# rounds the values in its first argument to the specified number of significant digits.
waldtestpV(anchorpoint_test, shift = -1,digits = 1)
graphicalTest(anchorpoint_test)
graphicalTest(anchorpoint_test, shift = 1,cex.axis = .9,cex.lab = .9,cex.main = 1)
shiftPlot(anchorpoint_test) #change legend size with cex = ..
shiftPlot(anchorpoint_test,shift = 5,cex.main = .1)
devtools::document()
devtools::check()
devtools::build()
#setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('plotCriterion_shiny.R')
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('plotCriterion_shiny.R')
remove.packages("anchorpoint")
install.packages("../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
shiny::runApp()
runApp()
runApp()
runApp()
?anchorpoint
?getWald
?multiDGP
?dgp_multi
?getData
devtools::document
devtools::document()
devtools::check()
devtools::check()
devtools::build()
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('plotCriterion_shiny.R')
install.packages("../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
#install.packages("../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
library(anchorpoint)
shiny::runApp()
runApp()
runApp()
list.files()
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('Abilities.R')
source('cmax.R')
source('CLF.R')
source('genGrid.R')
source('getRM.R')
source('getWald.R')
source('graphicalTest.R')
source('manuelInput.R')
source('multi_dim_DGP.R')
source('one_dim_DGP.R')
source('plotCriterion_shiny.R')
source('plotData.R')
source('plotShift_shiny.R')
source('rm_g.R')
source('Wald_test.R')
plotData
runApp()
runApp()
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('Abilities.R')
source('cmax.R')
source('CLF.R')
source('genGrid.R')
source('getRM.R')
source('getWald.R')
source('graphicalTest.R')
source('manuelInput.R')
source('multi_dim_DGP.R')
source('one_dim_DGP.R')
source('plotCriterion_shiny.R')
source('plotData.R')
source('plotShift_shiny.R')
source('rm_g.R')
source('Wald_test.R')
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('Abilities.R')
source('cmax.R')
source('CLF.R')
source('genGrid.R')
source('getRM.R')
source('getWald.R')
source('graphicalTest.R')
source('manuelInput.R')
source('multi_dim_DGP.R')
source('one_dim_DGP.R')
source('plotCriterion_shiny.R')
source('plotData.R')
source('plotShift_shiny.R')
source('rm_g.R')
source('Wald_test.R')
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('Abilities.R')
source('cmax.R')
source('CLF.R')
source('genGrid.R')
source('getRM.R')
source('getWald.R')
source('graphicalTest.R')
source('multi_dim_DGP.R')
source('one_dim_DGP.R')
source('plotCriterion_shiny.R')
source('plotData.R')
source('plotShift_shiny.R')
source('rm_g.R')
source('Wald_test.R')
runApp()
plotData
runApp()
runApp()
getWald
shiftPlot
plotCriterion
runApp()
getWald
Wald_test
source('diftests.R')
runApp()
source('Wald_test.R')
devtools::check()
devtools::build()
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('plotCriterion_shiny.R')
install.packages("../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
#install.packages("../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
library(anchorpoint)
library(shiny)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
source('plotCriterion_shiny.R')
install.packages("../../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
devtools::document()
devtools::check()
devtools::build()
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
install.packages("../../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
shiny::runApp()
runApp()
runApp()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::build()
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
install.packages("../../../anchorpoint_0.0.0.9000.tar.gz", repos = NULL, type="source")
shiny::runApp()
runApp()
runApp()
runApp()
file.path(getwd(),'anchorpoint_0.0.0.9000.tar.gz')
devtools::install(file.path(getwd(),'anchorpoint') )
runApp()
runApp()
devtools::build()
devtools::document()
devtools::check()
devtools::build()
devtools::document()
devtools::check()
devtools::build()
devtools::document()
devtools::check()
devtools::build()
